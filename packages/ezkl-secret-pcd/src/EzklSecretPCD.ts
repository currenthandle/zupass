import {
  DisplayOptions,
  PCD,
  PCDPackage,
  SerializedPCD,
  StringArgument
} from "@pcd/pcd-types";
import JSONBig from "json-bigint";
import { v4 as uuid } from "uuid";
import { EzklSecretCardBody } from "./CardBody";

function stringToFloat(str: string) {
  let result = "";
  for (let i = 0; i < str.length; i++) {
    result += str.charCodeAt(i).toString();
  }
  return parseFloat(result);
}

function unit8ArrayToJsonObect(uint8Array: Uint8Array) {
  // let string = new TextDecoder("utf-8").decode(uint8Array);
  let string = new TextDecoder().decode(uint8Array);
  let jsonObject = JSON.parse(string);
  return jsonObject;
}

async function getFloatToVecU64() {
  try {
    const module = await import("@ezkljs/engine/web/ezkl");
    const floatToVecU64 = module.floatToVecU64;
    return floatToVecU64;
  } catch (err) {
    console.error("Failed to import module:", err);
  }
}

async function getPoseidonHash() {
  try {
    const module = await import("@ezkljs/engine/web/ezkl");
    const poseidonHash = module.poseidonHash;
    return poseidonHash;
  } catch (err) {
    console.error("Failed to import module:", err);
  }
}

async function getInit() {
  try {
    const module = await import("@ezkljs/engine/web/ezkl");
    const init = module.default;
    return init;
  } catch (err) {
    console.error("Failed to import module:", err);
  }
}
export const EzklSecretPCDTypeName = "ezkl-secret-pcd";

// all fields in Args need to conform to interface Argument from pcd.ts
export interface EzklSecretPCDArgs {
  secret: StringArgument;
}

export interface EzklSecretPCDClaim {
  hash: Uint8ClampedArray;
}

export interface EzklSecretPCDProof {
  // hash: Uint8ClampedArray;
  clearSecret: string;
}

export class EzklSecretPCD
  implements PCD<EzklSecretPCDClaim, EzklSecretPCDProof>
{
  type = EzklSecretPCDTypeName;
  claim: EzklSecretPCDClaim;
  proof: EzklSecretPCDProof;
  id: string;

  public constructor(
    id: string,
    claim: EzklSecretPCDClaim,
    proof: EzklSecretPCDProof
  ) {
    this.id = id;
    this.claim = claim;
    this.proof = proof;
  }
}

// prove args come from PCD Pass autogeneratedn UI
// we'll need userProvided to be true for the secret
export async function prove(args: EzklSecretPCDArgs): Promise<EzklSecretPCD> {
  if (!args.secret.value || args.secret.value === "") {
    throw new Error("Secret is required");
  }

  const init = await getInit();
  if (!init) {
    throw new Error("Init not found");
  }
  await init(
    // undefined,
    // "http://localhost:3000/ezkl-artifacts/ezkl_bg.wasm",
    // "https://passport-client-3km0.onrender.com/ezkl-artifacts/ezkl_bg.wasm",
    "/ezkl-artifacts/ezkl_bg.wasm",
    new WebAssembly.Memory({ initial: 20, maximum: 1024, shared: true })
  );

  const float = stringToFloat(args.secret.value);

  const floatToVecU64 = await getFloatToVecU64();
  if (!floatToVecU64) {
    throw new Error("Float to vec u64 not found");
  }
  const u64Ser = floatToVecU64(float, 0);
  const u64Output = unit8ArrayToJsonObect(new Uint8Array(u64Ser.buffer));
  const u64Array = [u64Output];

  const string = JSONBig.stringify(u64Array);
  const buffer = new TextEncoder().encode(string);
  const u64sOutputSer = new Uint8ClampedArray(buffer.buffer);

  const poseidonHash = await getPoseidonHash();
  if (!poseidonHash) {
    throw new Error("Poseidon hash not found");
  }
  const hash = await poseidonHash(u64sOutputSer);
  console.log("hashed", hash);
  const decodedHash = new TextDecoder().decode(new Uint8Array(hash));
  // const stringy = JSONBig.stringify(decodedHash);
  const hashObj = JSONBig.parse(decodedHash);
  console.log("decoded hash", decodedHash);
  console.log("hashObj", hashObj);

  await fetch("http://localhost:5001/add_number", {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: decodedHash
  });

  const claim: EzklSecretPCDClaim = { hash };
  const proof: EzklSecretPCDProof = { clearSecret: args.secret.value };

  return new EzklSecretPCD(uuid(), claim, proof);
}

export async function verify(pcd: EzklSecretPCD): Promise<boolean> {
  // todo also run posidoeon hash
  // const { claim, proof } = pcd;
  // for (let i = 0; i < claim.hash.length; i++) {
  //   if (claim.hash[i] !== proof.hash[i]) {
  //     return false;
  //   }
  // }
  return true;
}

export async function serialize(
  pcd: EzklSecretPCD
): Promise<SerializedPCD<EzklSecretPCD>> {
  return {
    type: EzklSecretPCDTypeName,
    pcd: JSONBig().stringify(pcd)
  } as SerializedPCD<EzklSecretPCD>;
}

export async function deserialize(serialized: string): Promise<EzklSecretPCD> {
  return JSONBig().parse(serialized);
}

export function getDisplayOptions(pcd: EzklSecretPCD): DisplayOptions {
  return {
    header: "Ezkl Secret PCD",
    // displayName: "ezkl-secret-" + pcd.id.substring(0, 4)
    displayName: "ezkl-secret-" + pcd.id.substring(0, 4)
  };
}

// look into this later
export const EzklSecretPCDPackage: PCDPackage<
  EzklSecretPCDClaim,
  EzklSecretPCDProof,
  EzklSecretPCDArgs
> = {
  name: EzklSecretPCDTypeName,
  renderCardBody: EzklSecretCardBody,
  getDisplayOptions,
  prove,
  verify,
  serialize,
  deserialize
};
